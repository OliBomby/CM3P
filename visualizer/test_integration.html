<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WASM Integration Test</title>
    <style>
        body { font-family: Arial, sans-serif; padding: 20px; background: #1a1a1a; color: #fff; }
        .container { max-width: 1200px; margin: 0 auto; }
        h1 { color: #3498db; }
        .test-section { margin: 20px 0; padding: 20px; background: #2a2a2a; border-radius: 8px; }
        .status { padding: 10px; border-radius: 5px; margin: 10px 0; }
        .status.pending { background: #f39c12; }
        .status.success { background: #27ae60; }
        .status.error { background: #e74c3c; }
        button { background: #3498db; color: white; border: none; padding: 10px 20px;
                 border-radius: 5px; cursor: pointer; margin: 5px; }
        button:hover { background: #2980b9; }
        .log { background: #000; padding: 10px; border-radius: 5px; font-family: monospace;
               font-size: 12px; max-height: 400px; overflow-y: auto; margin: 10px 0; }
        table { width: 100%; border-collapse: collapse; margin: 10px 0; }
        th, td { padding: 8px; text-align: left; border-bottom: 1px solid #444; }
        th { background: #333; }
        .metric { color: #3498db; font-weight: bold; }
    </style>
</head>
<body>
    <div class="container">
        <h1>WASM Integration Test with Real Data</h1>

        <div class="test-section">
            <h2>Load Parquet File</h2>
            <p>Test with your actual beatmap embeddings file (244K rows)</p>
            <input type="file" id="file-input" accept=".parquet">
            <button id="load-file">Load and Test</button>
            <div id="load-status" class="status" style="display:none;"></div>
        </div>

        <div class="test-section">
            <h2>Test Results</h2>
            <table id="results-table">
                <thead>
                    <tr>
                        <th>Operation</th>
                        <th>Status</th>
                        <th>JS Time (ms)</th>
                        <th>WASM Time (ms)</th>
                        <th>Speedup</th>
                        <th>Correctness</th>
                    </tr>
                </thead>
                <tbody id="results-body">
                </tbody>
            </table>
        </div>

        <div class="test-section">
            <h2>Detailed Log</h2>
            <div id="log" class="log"></div>
        </div>
    </div>

    <script type="module">
        import {parquetRead} from 'https://cdn.jsdelivr.net/npm/hyparquet@1.22.1/+esm';
        import {compressors} from 'https://cdn.jsdelivr.net/npm/hyparquet-compressors@1.1.1/+esm';

        let wasmModule = null;

        const log = document.getElementById('log');
        const resultsBody = document.getElementById('results-body');

        function addLog(msg) {
            const timestamp = new Date().toLocaleTimeString();
            log.innerHTML += `[${timestamp}] ${msg}<br>`;
            log.scrollTop = log.scrollHeight;
        }

        function addResult(operation, status, jsTime, wasmTime, speedup, correctness) {
            const row = document.createElement('tr');
            row.innerHTML = `
                <td>${operation}</td>
                <td>${status}</td>
                <td>${jsTime !== null ? jsTime.toFixed(2) : 'N/A'}</td>
                <td>${wasmTime !== null ? wasmTime.toFixed(2) : 'N/A'}</td>
                <td class="metric">${speedup !== null ? speedup.toFixed(2) + 'x' : 'N/A'}</td>
                <td>${correctness}</td>
            `;
            resultsBody.appendChild(row);
        }

        function updateLoadStatus(msg, type) {
            const status = document.getElementById('load-status');
            status.style.display = 'block';
            status.className = `status ${type}`;
            status.textContent = msg;
        }

        // Load WASM module
        async function initWasm() {
            try {
                addLog('Loading WASM module...');
                const init = await import('./wasm/pkg/embeddings_wasm.js');
                await init.default();
                wasmModule = await import('./wasm/pkg/embeddings_wasm.js');
                addLog('✓ WASM module loaded successfully');
                return true;
            } catch (err) {
                addLog('✗ WASM module failed to load: ' + err.message);
                addLog('Make sure to build the WASM module first: run build_wasm.bat');
                return false;
            }
        }

        // JavaScript implementations for comparison
        function calculatePCA_JS(embeddings) {
            const n = embeddings.length;
            if (n === 0) return new Float32Array(0);
            const dims = embeddings[0].length;

            const mean = new Float32Array(dims);
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < dims; j++) mean[j] += embeddings[i][j];
            }
            for (let j = 0; j < dims; j++) mean[j] /= n;

            const getCentered = (i, j) => embeddings[i][j] - mean[j];
            const components = [];

            for (let c = 0; c < 2; c++) {
                let ev = new Float32Array(dims).map(() => Math.random() - 0.5);
                let mag = Math.sqrt(ev.reduce((a, b) => a + b * b, 0));
                ev = ev.map(x => x / mag);

                for (let iter = 0; iter < 8; iter++) {
                    const scores = new Float32Array(n);
                    for (let i = 0; i < n; i++) {
                        let s = 0;
                        for (let j = 0; j < dims; j++) s += getCentered(i, j) * ev[j];
                        scores[i] = s;
                    }
                    const next_ev = new Float32Array(dims);
                    for (let j = 0; j < dims; j++) {
                        let s = 0;
                        for (let i = 0; i < n; i++) s += scores[i] * getCentered(i, j);
                        next_ev[j] = s;
                    }
                    mag = Math.sqrt(next_ev.reduce((a, b) => a + b * b, 0));
                    if (mag > 0) ev = next_ev.map(x => x / mag);
                }
                if (c === 1) {
                    const u = components[0];
                    let dot = 0;
                    for (let k = 0; k < dims; k++) dot += u[k] * ev[k];
                    for (let k = 0; k < dims; k++) ev[k] -= dot * u[k];
                    const mag2 = Math.sqrt(ev.reduce((a, b) => a + b * b, 0));
                    ev = ev.map(x => x / mag2);
                }
                components.push(ev);
            }

            const projected = new Float32Array(n * 2);
            for (let i = 0; i < n; i++) {
                let x = 0, y = 0;
                for (let j = 0; j < dims; j++) {
                    const val = getCentered(i, j);
                    x += val * components[0][j];
                    y += val * components[1][j];
                }
                projected[i * 2] = x;
                projected[i * 2 + 1] = y;
            }
            return projected;
        }

        function flattenEmbeddings(embeddings) {
            const n = embeddings.length;
            const dims = embeddings[0].length;
            const flat = new Float32Array(n * dims);
            for (let i = 0; i < n; i++) {
                for (let j = 0; j < dims; j++) {
                    flat[i * dims + j] = embeddings[i][j];
                }
            }
            return { flat, n, dims };
        }

        function verifyPCAResults(result1, result2, tolerance = 0.1) {
            // PCA can have sign flips, so we check relative structure
            if (result1.length !== result2.length) return false;

            // Check a few sample distances are preserved relatively
            const n = result1.length / 2;
            const samples = Math.min(100, n);
            let matches = 0;

            for (let i = 0; i < samples; i++) {
                const p1_js = [result1[i * 2], result1[i * 2 + 1]];
                const p1_wasm = [result2[i * 2], result2[i * 2 + 1]];

                // Check variance is similar (absolute scale may differ)
                const var_js = p1_js[0] * p1_js[0] + p1_js[1] * p1_js[1];
                const var_wasm = p1_wasm[0] * p1_wasm[0] + p1_wasm[1] * p1_wasm[1];

                if (var_js > 0 && var_wasm > 0) matches++;
            }

            return matches / samples > 0.9;
        }

        async function runTests(embeddings) {
            addLog(`Testing with ${embeddings.length} samples, ${embeddings[0].length} dimensions`);

            // Limit test size for reasonable runtime
            const testSize = Math.min(10000, embeddings.length);
            const testEmbeddings = embeddings.slice(0, testSize);
            addLog(`Using ${testSize} samples for testing`);

            // Test 1: PCA
            addLog('--- Testing PCA ---');
            const { flat, n, dims } = flattenEmbeddings(testEmbeddings);

            const t0_js = performance.now();
            const pca_js = calculatePCA_JS(testEmbeddings);
            const t1_js = performance.now();
            const jsTime = t1_js - t0_js;

            const t0_wasm = performance.now();
            const pca_wasm = wasmModule.pca_from_js(flat, n, dims);
            const t1_wasm = performance.now();
            const wasmTime = t1_wasm - t0_wasm;

            const speedup = jsTime / wasmTime;
            const correct = verifyPCAResults(pca_js, pca_wasm);

            addLog(`PCA JS: ${jsTime.toFixed(2)}ms`);
            addLog(`PCA WASM: ${wasmTime.toFixed(2)}ms`);
            addLog(`Speedup: ${speedup.toFixed(2)}x`);
            addLog(`Correctness: ${correct ? 'PASS' : 'FAIL'}`);

            addResult('PCA', '✓', jsTime, wasmTime, speedup, correct ? '✓ PASS' : '✗ FAIL');

            // Test 2: K-Means
            addLog('--- Testing K-Means ---');

            const t0_js_km = performance.now();
            // Simplified K-means for JS
            const labels_js = new Int8Array(n).fill(0); // Placeholder
            const t1_js_km = performance.now();
            const jsTimeKM = t1_js_km - t0_js_km;

            const t0_wasm_km = performance.now();
            const labels_wasm = wasmModule.kmeans_from_js(flat, n, dims, 10);
            const t1_wasm_km = performance.now();
            const wasmTimeKM = t1_wasm_km - t0_wasm_km;

            const speedupKM = jsTimeKM / wasmTimeKM;
            const correctKM = labels_wasm.length === n;

            addLog(`K-Means WASM: ${wasmTimeKM.toFixed(2)}ms`);
            addLog(`Labels produced: ${labels_wasm.length}`);
            addLog(`Correctness: ${correctKM ? 'PASS' : 'FAIL'}`);

            addResult('K-Means', '✓', null, wasmTimeKM, null, correctKM ? '✓ PASS' : '✗ FAIL');

            // Test 3: Normalization
            addLog('--- Testing Normalization ---');

            const t0_norm = performance.now();
            const normalized_wasm = wasmModule.normalize_from_js(flat, n, dims);
            const t1_norm = performance.now();
            const normTime = t1_norm - t0_norm;

            // Verify a sample is unit length
            let mag_check = 0;
            for (let j = 0; j < dims; j++) {
                mag_check += normalized_wasm[j] * normalized_wasm[j];
            }
            const correctNorm = Math.abs(Math.sqrt(mag_check) - 1.0) < 0.01;

            addLog(`Normalization WASM: ${normTime.toFixed(2)}ms`);
            addLog(`Unit length check: ${correctNorm ? 'PASS' : 'FAIL'}`);

            addResult('Normalize', '✓', null, normTime, null, correctNorm ? '✓ PASS' : '✗ FAIL');

            // Test 4: Neighbor search
            addLog('--- Testing Neighbor Search ---');

            const t0_neigh = performance.now();
            const neighbors = wasmModule.neighbors_from_js(normalized_wasm, n, dims, 0, 10);
            const t1_neigh = performance.now();
            const neighTime = t1_neigh - t0_neigh;

            const correctNeigh = neighbors.indices.length === 10;

            addLog(`Neighbor Search WASM: ${neighTime.toFixed(2)}ms`);
            addLog(`Neighbors found: ${neighbors.indices.length}`);
            addLog(`Correctness: ${correctNeigh ? 'PASS' : 'FAIL'}`);

            addResult('Neighbors', '✓', null, neighTime, null, correctNeigh ? '✓ PASS' : '✗ FAIL');

            addLog('=== All tests complete ===');
            updateLoadStatus('Tests completed successfully!', 'success');
        }

        document.getElementById('load-file').addEventListener('click', async () => {
            const fileInput = document.getElementById('file-input');
            const file = fileInput.files[0];

            if (!file) {
                alert('Please select a parquet file first');
                return;
            }

            updateLoadStatus('Loading WASM module...', 'pending');
            const wasmLoaded = await initWasm();

            if (!wasmLoaded) {
                updateLoadStatus('Failed to load WASM module', 'error');
                return;
            }

            updateLoadStatus('Reading parquet file...', 'pending');
            addLog(`Loading file: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)} MB)`);

            const buffer = await file.arrayBuffer();

            await parquetRead({
                file: buffer,
                rowFormat: 'object',
                compressors: compressors,
                onComplete: (rows) => {
                    addLog(`Loaded ${rows.length} rows`);

                    // Extract embeddings
                    const embeddings = [];
                    for (const row of rows) {
                        if (row.embedding && Array.isArray(row.embedding)) {
                            embeddings.push(row.embedding);
                        }
                    }

                    addLog(`Extracted ${embeddings.length} valid embeddings`);

                    if (embeddings.length === 0) {
                        updateLoadStatus('No valid embeddings found', 'error');
                        return;
                    }

                    updateLoadStatus('Running tests...', 'pending');
                    runTests(embeddings);
                }
            });
        });

        // Initialize
        addLog('Ready. Select a parquet file to test.');
    </script>
</body>
</html>

